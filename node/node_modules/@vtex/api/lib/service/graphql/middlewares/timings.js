"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ramda_1 = require("ramda");
const pathname_1 = require("../utils/pathname");
const nanoToMillis = (nanoseconds) => Math.round((nanoseconds / 1e6));
const hasErrorForPathName = (pathName, graphQLErrors) => {
    return graphQLErrors && ramda_1.any(ramda_1.propEq('pathName', pathName), graphQLErrors) || false;
};
const batchResolversTracing = (resolvers, graphQLErrors) => {
    resolvers.forEach(resolver => {
        const pathName = pathname_1.generatePathName(resolver.path);
        const status = hasErrorForPathName(pathName, graphQLErrors)
            ? 'error'
            : 'success';
        const extensions = {
            fieldName: resolver.fieldName,
            parentType: resolver.parentType,
            pathName,
            returnType: resolver.returnType,
        };
        if (resolver.parentType === 'Query') {
            metrics.batchMetric(`graphql-resolver-${status}-${pathName}`, nanoToMillis(resolver.duration), extensions);
        }
    });
};
async function graphqlTimings(ctx, next) {
    const start = process.hrtime();
    // Errors will be caught by the next middleware so we don't have to catch.
    await next();
    // Batch success or error metric for entire operation
    metrics.batch(`graphql-operation-${ctx.graphql.status}`, process.hrtime(start));
    // Batch timings for individual resolvers
    const resolverTimings = ramda_1.path(['extensions', 'tracing', 'execution', 'resolvers'], ctx.graphql.graphqlResponse);
    if (resolverTimings) {
        batchResolversTracing(resolverTimings, ctx.graphql.graphQLErrors);
    }
}
exports.graphqlTimings = graphqlTimings;
